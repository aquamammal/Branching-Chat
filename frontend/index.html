<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Branching Chat – Columnar Tree</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 0;
      background: #050505;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 10px 16px;
      background: #080808;
      border-bottom: 1px solid #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      font-size: 16px;
      margin: 0;
    }

    header button {
      border-radius: 999px;
      border: 1px solid #444;
      background: #151515;
      color: #eee;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    header button:hover {
      background: #222;
    }

    /* MAIN CANVAS */
    #thread-container {
      position: relative;
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: auto;
      padding: 80px 16px 80px 16px;  /* breathing room */
      gap: 16px;
      scroll-behavior: smooth;
      align-items: flex-start;
    }

    .depth-column {
      flex: 0 0 340px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      justify-content: flex-start;
      transform: translateY(0px); /* adjusted by JS */
    }

    .depth-label {
      font-size: 11px;
      opacity: 0.6;
      margin-bottom: 4px;
      padding-left: 4px;
    }

    .thread {
      display: flex;
      flex-direction: column;
      background: #101010;
      border-radius: 10px;
      border: 1px solid #333;
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
      max-height: 420px;
      transition:
        transform 0.15s ease,
        opacity 0.15s ease,
        max-height 0.15s ease,
        margin-top 0.2s ease;
      margin-top: var(--y-offset, 0px);
      z-index: 1;                /* above connection lines */
    }

    .thread.active {
      transform: scale(1.03);
      max-height: 640px;
      z-index: 2;
    }

    .thread.collapsed {
      transform: scale(0.96);
      opacity: 0.8;
      max-height: 320px;
    }

    .thread-header {
      padding: 6px 10px;
      border-bottom: 1px solid #222;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #151515;
      border-radius: 10px 10px 0 0;
      cursor: pointer;
      gap: 6px;
    }

    .thread-title {
      font-weight: 500;
    }

    .thread-meta {
      font-size: 10px;
      opacity: 0.7;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .thread-body {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .thread-footer {
      padding: 8px;
      border-top: 1px solid #222;
      display: flex;
      gap: 6px;
      background: #0b0b0b;
      border-radius: 0 0 10px 10px;
    }

    .msg {
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 13px;
      position: relative;
      white-space: pre-wrap;
    }

    .msg.user {
      align-self: flex-end;
      background: #24496e;
    }

    .msg.assistant {
      align-self: flex-start;
      background: #262626;
    }

    .msg.system {
      align-self: center;
      background: #111;
      opacity: 0.9;
      font-size: 11px;
    }

    .msg-meta {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 2px;
      display: flex;
      justify-content: space-between;
      gap: 6px;
    }

    .msg-role {
      text-transform: uppercase;
    }

    .msg-text {
      font-size: 13px;
    }

    .branch-highlight {
      background: #2a7c52;
      padding: 0 2px;
      border-radius: 2px;
    }

    input[type="text"] {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #050505;
      color: #eee;
      font-size: 13px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #555;
    }

    button {
      border: 1px solid #444;
      background: #151515;
      color: #eee;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    button:hover {
      background: #222;
    }

    .badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444;
      background: rgba(255, 255, 255, 0.04);
    }

    .thread-close-btn {
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 11px;
      line-height: 1;
      border: 1px solid #444;
      background: #151515;
      color: #eee;
      cursor: pointer;
    }

    .thread-close-btn:hover {
      background: #222;
    }

    #selection-branch-btn {
      position: absolute;
      z-index: 1000;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      cursor: pointer;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }

    /* SVG LINES LAYER */

    #connection-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
      z-index: 0;
    }

    .thread-connection {
      fill: none;
      stroke: #4ade80;
      stroke-width: 1.6;
      opacity: 0.7;
    }
  </style>
</head>
<body>
<header>
  <h1>Branching Chat (Columns by Depth)</h1>
  <button id="new-root-btn">+ New root conversation</button>
</header>

<div id="thread-container"></div>
<button id="selection-branch-btn">Branch selection →</button>

<script>
  // ---------- Data ----------
  let threadCounter = 1;
  let messageCounter = 1;
  let highlightCounter = 1;
  let activeThreadId = null;

  // after render, if this is set we focus that thread's input
  let pendingFocusThreadId = null;

  const threads = [];

  function setActiveThread(id) {
    activeThreadId = id;
    pendingFocusThreadId = id;  // focus its input after render
    render();
  }

  function createThread({
    title,
    depth,
    parentId = null,
    parentSnippet = null,
    visibleSnippet = null,
    branchSource = null   // { parentThreadId, parentMessageId, position }
  }) {
    const id = "t" + threadCounter++;

    const messages = [];

    if (parentSnippet) {
      messages.push({
        id: "m" + messageCounter++,
        role: "system",
        content: parentSnippet,       // full hidden context for the model
        visibleSnippet: visibleSnippet // short snippet we actually display
      });
    } else {
      messages.push({
        id: "m" + messageCounter++,
        role: "system",
        content: "You are a helpful local assistant in a root conversation node."
      });
    }

    const thread = {
      id,
      depth,
      parentId,
      parentSnippet,
      title,
      messages,
      branchSource,        // where in the parent this came from
      seq: threadCounter   // creation sequence as a tiebreaker
    };

    threads.push(thread);

    if (!activeThreadId) activeThreadId = thread.id;
    return thread;
  }

  const containerEl = document.getElementById("thread-container");
  const selectionBranchBtn = document.getElementById("selection-branch-btn");

  // ---------- Helpers: scrolling & focus ----------

  function scrollAllThreadsToBottom() {
    const bodies = containerEl.querySelectorAll(".thread-body");
    bodies.forEach(b => {
      b.scrollTop = b.scrollHeight;
    });
  }

  function keepThreadScrolledToBottom(threadId) {
    const threadEl = [...document.querySelectorAll(".thread")]
      .find(el => el.dataset.threadId === threadId);
    if (!threadEl) return;
    const bodyEl = threadEl.querySelector(".thread-body");
    if (!bodyEl) return;
    bodyEl.scrollTop = bodyEl.scrollHeight;
  }

  function focusInputForThread(threadId) {
    const inputEl = document.querySelector(
      `.thread[data-thread-id="${threadId}"] input[type="text"]`
    );
    if (inputEl) {
      inputEl.focus();
      const val = inputEl.value;
      inputEl.value = "";
      inputEl.value = val;
    }
  }

  // ---------- Messaging ----------

  function addUserMessage(threadId, text) {
    const thread = threads.find(t => t.id === threadId);
    if (!thread || !text.trim()) return;

    thread.messages.push({
      id: "m" + messageCounter++,
      role: "user",
      content: text.trim()
    });

    render();
    keepThreadScrolledToBottom(threadId);
    sendToBackend(thread);
  }

  async function sendToBackend(thread) {
    const payloadMessages = thread.messages.map(m => ({
      role: m.role,
      content: m.content
    }));

    const thinking = {
      id: "m" + messageCounter++,
      role: "assistant",
      content: "…"
    };
    thread.messages.push(thinking);
    render();
    keepThreadScrolledToBottom(thread.id);

    try {
      const resp = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          thread_id: thread.id,
          messages: payloadMessages
        })
      });

      const data = await resp.json();
      thinking.content = data.reply ?? "(no reply)";
      render();
      keepThreadScrolledToBottom(thread.id);
    } catch (err) {
      thinking.content = "Error: " + err;
      render();
      keepThreadScrolledToBottom(thread.id);
    }
  }

  // ---------- Selection / branching ----------

  function clearSelection() {
    const sel = window.getSelection && window.getSelection();
    if (sel && sel.removeAllRanges) sel.removeAllRanges();
  }

  // Return both raw and trimmed selection for better indexing + nicer display
  function getSelectedTextInside(el) {
    const sel = window.getSelection && window.getSelection();
    if (!sel || sel.rangeCount === 0) return { raw: null, trimmed: null };

    const range = sel.getRangeAt(0);
    if (!el.contains(range.commonAncestorContainer)) {
      return { raw: null, trimmed: null };
    }

    const raw = sel.toString();
    const trimmed = raw.trim();

    if (!trimmed.length) {
      return { raw: null, trimmed: null };
    }

    return { raw, trimmed };
  }

  // Global mid-character index across conversation, with "round up for even length"
  function computeGlobalSelectionMidIndex(parentThread, msg, rawSel, trimmedSel) {
    const selText =
      rawSel && rawSel.length
        ? rawSel
        : trimmedSel && trimmedSel.length
        ? trimmedSel
        : "";

    let totalChars = 0;
    let midGlobal = 0;

    for (const m of parentThread.messages) {
      const text = m.content || "";
      if (m === msg) {
        let idx = 0;
        if (selText) {
          const found = text.indexOf(selText);
          if (found >= 0) idx = found;
        }

        const selLen = selText ? selText.length : 1;

        let midInMsg;
        if (selLen % 2 === 1) {
          midInMsg = (selLen - 1) / 2;   // odd
        } else {
          midInMsg = selLen / 2;         // even, rounded up in 1-based terms
        }

        midGlobal = totalChars + idx + midInMsg;
      }
      totalChars += text.length;
    }

    return midGlobal;
  }

  // Build a richer snippet: paragraph + selection + bit of the rest
  function buildContextSnippet(msg, selectedText) {
    const full = msg.content || "";
    const s = selectedText || "";

    if (!s) {
      return full.slice(0, 1000);
    }

    const idx = full.indexOf(s);
    if (idx === -1) {
      return full.slice(0, 1000);
    }

    const before = full.lastIndexOf("\n\n", idx);
    const after = full.indexOf("\n\n", idx + s.length);
    const paraStart = before === -1 ? 0 : before + 2;
    const paraEnd = after === -1 ? full.length : after;
    const paragraph = full.slice(paraStart, paraEnd).trim();

    const rest = (full.slice(0, paraStart) + "\n" + full.slice(paraEnd)).trim();
    const restTrunc = rest.slice(0, 400);

    let snippet = "";
    snippet += `Paragraph context:\n"${paragraph}"\n\n`;
    snippet += `Focused selection:\n"${s}"\n\n`;
    if (restTrunc.length) {
      snippet += `Other context from the same answer (truncated):\n"${restTrunc}"`;
    }
    return snippet;
  }

  // Create branch node; ordering based on global mid-character index
  function branchFromMessage(parentThreadId, messageId, msgElement, forcedSnippet = null) {
    const parentThread = threads.find(t => t.id === parentThreadId);
    if (!parentThread) return;

    const msg = parentThread.messages.find(m => m.id === messageId);
    if (!msg) return;

    const selInfo = getSelectedTextInside(msgElement);
    const rawSel = selInfo.raw;
    const trimmedSel = selInfo.trimmed;

    const globalMid = computeGlobalSelectionMidIndex(
      parentThread,
      msg,
      rawSel,
      trimmedSel
    );

    let snippet;
    if (forcedSnippet) {
      snippet = forcedSnippet;
    } else {
      snippet = buildContextSnippet(msg, trimmedSel);
    }

    const newDepth = parentThread.depth + 1;
    const visibleSnippet = trimmedSel || snippet.slice(0, 120);

    const childThread = createThread({
      title: `Branch of ${parentThread.id}`,
      depth: newDepth,
      parentId: parentThread.id,
      parentSnippet: snippet,
      visibleSnippet,
      branchSource: {
        parentThreadId: parentThread.id,
        parentMessageId: msg.id,
        position: globalMid
      }
    });

    if (!msg.highlights) msg.highlights = [];
    msg.highlights.push({
      id: "h" + highlightCounter++,
      text: visibleSnippet,
      targetThreadId: childThread.id
    });

    activeThreadId = childThread.id;
    pendingFocusThreadId = childThread.id;
    render();
    scrollToRight();
  }

  // Selection can come from ANY message
  document.addEventListener("selectionchange", () => {
    const sel = window.getSelection && window.getSelection();
    if (!sel || sel.rangeCount === 0) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const range = sel.getRangeAt(0);
    const container = range.commonAncestorContainer;

    const msgEl = container.nodeType === 1
      ? container.closest(".msg")
      : container.parentElement && container.parentElement.closest(".msg");

    if (!msgEl) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const threadEl = msgEl.closest(".thread");
    if (!threadEl) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const selectedText = sel.toString().trim();
    if (!selectedText.length) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const rect = range.getBoundingClientRect();
    selectionBranchBtn.style.display = "block";
    selectionBranchBtn.style.left = (rect.left + rect.width / 2 - 50) + window.scrollX + "px";
    selectionBranchBtn.style.top = (rect.top - 30) + window.scrollY + "px";

    selectionBranchBtn.dataset.threadId = threadEl.dataset.threadId;
    selectionBranchBtn.dataset.messageId = msgEl.dataset.messageId;
  });

  selectionBranchBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    const threadId = selectionBranchBtn.dataset.threadId;
    const messageId = selectionBranchBtn.dataset.messageId;

    if (!threadId || !messageId) return;

    const msgEl = document.querySelector(
      `.thread[data-thread-id="${threadId}"] .msg[data-message-id="${messageId}"]`
    );
    if (!msgEl) return;

    branchFromMessage(threadId, messageId, msgEl);
    selectionBranchBtn.style.display = "none";
    clearSelection();
  });

  // ---------- Close thread (and all descendants) ----------

  function closeThread(threadId) {
    const toDelete = new Set([threadId]);

    let changed = true;
    while (changed) {
      changed = false;
      for (const t of threads) {
        if (!toDelete.has(t.id) && t.parentId && toDelete.has(t.parentId)) {
          toDelete.add(t.id);
          changed = true;
        }
      }
    }

    threads.forEach(t => {
      t.messages.forEach(m => {
        if (m.highlights) {
          m.highlights = m.highlights.filter(
            h => !toDelete.has(h.targetThreadId)
          );
        }
      });
    });

    for (let i = threads.length - 1; i >= 0; i--) {
      if (toDelete.has(threads[i].id)) {
        threads.splice(i, 1);
      }
    }

    if (toDelete.has(activeThreadId)) {
      activeThreadId = threads.length ? threads[0].id : null;
    }

    pendingFocusThreadId = activeThreadId;
    render();
  }

  // ---------- Layout: vertical offsets + explicit order per depth ----------

  function computeVerticalLayout() {
    const byDepth = new Map();
    for (const t of threads) {
      if (!byDepth.has(t.depth)) byDepth.set(t.depth, []);
      byDepth.get(t.depth).push(t);
    }

    const offsets = new Map();
    const order = new Map();   // depth-local ordering index for render()
    const rowGap = 14;

    const depthKeys = [...byDepth.keys()].sort((a, b) => a - b);

    for (const depth of depthKeys) {
      const list = byDepth.get(depth);
      if (!list || list.length === 0) continue;

      let localRank = 0;

      if (depth === 0) {
        // Roots: simple stack
        list.sort((a, b) => (a.seq || 0) - (b.seq || 0));
        list.forEach((t, idx) => {
          offsets.set(t.id, idx * rowGap);
          order.set(t.id, localRank++);
        });
        continue;
      }

      // Depth > 0: group by parent, center around parent, avoid overlap
      const groupsMap = new Map();
      for (const t of list) {
        const pid = t.parentId || "__no_parent__";
        if (!groupsMap.has(pid)) groupsMap.set(pid, []);
        groupsMap.get(pid).push(t);
      }

      const groups = [];

      for (const [pid, children] of groupsMap.entries()) {
        // children order inside a parent group is by highlight position
        children.sort((a, b) => {
          const aPos =
            a.branchSource && a.branchSource.position != null
              ? a.branchSource.position
              : Infinity;
          const bPos =
            b.branchSource && b.branchSource.position != null
              ? b.branchSource.position
              : Infinity;

          if (aPos !== bPos) return aPos - bPos;
          return (a.seq || 0) - (b.seq || 0);
        });

        let parentIndex = null;
        if (pid !== "__no_parent__" && offsets.has(pid)) {
          parentIndex = (offsets.get(pid) || 0) / rowGap;
        }

        const n = children.length;
        const indices = [];

        if (parentIndex != null) {
          const start = parentIndex - (n - 1) / 2;
          for (let i = 0; i < n; i++) {
            indices.push(start + i);
          }
        } else {
          for (let i = 0; i < n; i++) indices.push(i);
        }

        let minIndex = Math.min(...indices);
        let maxIndex = Math.max(...indices);

        groups.push({
          parentId: pid,
          children,
          indices,
          minIndex,
          maxIndex,
          parentIndex
        });
      }

      groups.sort((a, b) => {
        const aKey = a.parentIndex != null ? a.parentIndex : a.minIndex;
        const bKey = b.parentIndex != null ? b.parentIndex : b.minIndex;
        return aKey - bKey;
      });

      let currentFloor = 0;
      for (const group of groups) {
        if (group.minIndex < currentFloor) {
          const delta = currentFloor - group.minIndex;
          group.indices = group.indices.map(v => v + delta);
          group.minIndex += delta;
          group.maxIndex += delta;
        }

        group.children.forEach((child, idx) => {
          const row = group.indices[idx];
          offsets.set(child.id, row * rowGap);
          order.set(child.id, localRank++);
        });

        currentFloor = group.maxIndex + 1;
      }
    }

    return { offsets, order };
  }

  // ---------- SVG CONNECTIONS ----------

  const SVG_NS = "http://www.w3.org/2000/svg";

  function ensureConnectionLayer() {
    let svg = containerEl.querySelector("#connection-layer");
    if (!svg) {
      svg = document.createElementNS(SVG_NS, "svg");
      svg.id = "connection-layer";
      containerEl.prepend(svg);
    }
    const rect = containerEl.getBoundingClientRect();
    svg.setAttribute("width", containerEl.scrollWidth);
    svg.setAttribute("height", containerEl.scrollHeight);
    svg.style.width = containerEl.scrollWidth + "px";
    svg.style.height = containerEl.scrollHeight + "px";
    svg.innerHTML = "";
    return { svg, containerRect: rect };
  }

  function drawConnections() {
    if (!threads.length) return;
    const { svg, containerRect } = ensureConnectionLayer();

    threads.forEach(thread => {
      if (!thread.parentId) return;

      const parentEl = containerEl.querySelector(
        `.thread[data-thread-id="${thread.parentId}"]`
      );
      const childEl = containerEl.querySelector(
        `.thread[data-thread-id="${thread.id}"]`
      );
      if (!parentEl || !childEl) return;

      const pr = parentEl.getBoundingClientRect();
      const cr = childEl.getBoundingClientRect();

      const x1 = pr.right - containerRect.left;
      const y1 = pr.top + pr.height / 2 - containerRect.top;
      const x2 = cr.left - containerRect.left;
      const y2 = cr.top + cr.height / 2 - containerRect.top;

      const dx = (x2 - x1) * 0.5;

      const path = document.createElementNS(SVG_NS, "path");
      const d = `M ${x1} ${y1} C ${x1 + dx} ${y1} ${x2 - dx} ${y2} ${x2} ${y2}`;
      path.setAttribute("d", d);
      path.setAttribute("class", "thread-connection");

      svg.appendChild(path);
    });
  }

  // ---------- Column centering relative to tallest column ----------

  function centerColumnsByTallest() {
    const cols = Array.from(containerEl.querySelectorAll(".depth-column"));
    if (cols.length <= 1) {
      drawConnections();
      return;
    }

    const containerRect = containerEl.getBoundingClientRect();
    const info = [];

    let tallestIndex = -1;
    let tallestHeight = 0;

    cols.forEach((col, idx) => {
      const threadsEls = Array.from(col.querySelectorAll(".thread"));
      if (!threadsEls.length) {
        info.push(null);
        return;
      }

      let minTop = Infinity;
      let maxBottom = -Infinity;

      threadsEls.forEach(el => {
        const r = el.getBoundingClientRect();
        const top = r.top - containerRect.top;
        const bottom = r.bottom - containerRect.top;
        if (top < minTop) minTop = top;
        if (bottom > maxBottom) maxBottom = bottom;
      });

      const height = maxBottom - minTop;
      info.push({ minTop, maxBottom, height });

      if (height > tallestHeight) {
        tallestHeight = height;
        tallestIndex = idx;
      }
    });

    if (tallestIndex === -1) {
      drawConnections();
      return;
    }

    const tallest = info[tallestIndex];
    const targetCenter = (tallest.minTop + tallest.maxBottom) / 2;

    cols.forEach((col, idx) => {
      const meta = info[idx];
      if (!meta) {
        col.style.transform = "translateY(0px)";
        return;
      }
      const center = (meta.minTop + meta.maxBottom) / 2;
      const delta = targetCenter - center;

      col.style.transform = `translateY(${delta}px)`;
    });

    drawConnections();
  }

  // ---------- Rendering ----------
  const newRootBtn = document.getElementById("new-root-btn");

  newRootBtn.onclick = () => {
    const t = createThread({
      title: "Root " + threadCounter,
      depth: 0,
      parentId: null,
      parentSnippet: null
    });
    activeThreadId = t.id;
    pendingFocusThreadId = t.id;
    render();
    scrollToRight();
  };

  function renderMessageText(msg, container) {
    const baseText = msg.visibleSnippet
      ? `Branch context: "${msg.visibleSnippet}"`
      : msg.content;

    if (!msg.highlights || msg.highlights.length === 0) {
      container.textContent = baseText;
      return;
    }

    let text = baseText;
    let cursor = 0;
    const highlights = msg.highlights.slice();

    for (const h of highlights) {
      const idx = text.indexOf(h.text, cursor);
      if (idx === -1) continue;

      if (idx > cursor) {
        const before = text.slice(cursor, idx);
        container.appendChild(document.createTextNode(before));
      }

      const span = document.createElement("span");
      span.className = "branch-highlight";
      span.dataset.highlightId = h.id;
      span.textContent = h.text;
      container.appendChild(span);

      cursor = idx + h.text.length;
    }

    if (cursor < text.length) {
      const after = text.slice(cursor);
      container.appendChild(document.createTextNode(after));
    }
  }

  function render() {
    containerEl.innerHTML = "";

    if (threads.length === 0) return;
    if (!activeThreadId && threads.length > 0) {
      activeThreadId = threads[0].id;
    }

    const { offsets, order } = computeVerticalLayout();
    const depths = [...new Set(threads.map(t => t.depth))].sort((a, b) => a - b);

    ensureConnectionLayer();

    for (const depth of depths) {
      const col = document.createElement("div");
      col.className = "depth-column";
      col.dataset.depth = depth;

      const label = document.createElement("div");
      label.className = "depth-label";
      label.textContent = depth === 0
        ? "Depth 0 (Genesis)"
        : `Depth ${depth} (branches of depth ${depth - 1})`;
      col.appendChild(label);

      let threadsForDepth = threads.filter(t => t.depth === depth);

      // IMPORTANT: sort DOM order by computed vertical order
      threadsForDepth.sort((a, b) => {
        const oa = order.get(a.id) ?? 0;
        const ob = order.get(b.id) ?? 0;
        return oa - ob;
      });

      for (const thread of threadsForDepth) {
        const threadEl = document.createElement("div");
        threadEl.className = "thread";
        threadEl.dataset.threadId = thread.id;

        threadEl.addEventListener("click", (e) => {
          const sel = window.getSelection && window.getSelection();
          if (sel && sel.toString().trim()) {
            return;
          }
          if (e.target.closest("input") || e.target.closest("button")) {
            return;
          }
          setActiveThread(thread.id);
        });

        const offset = offsets.get(thread.id) || 0;
        threadEl.style.setProperty("--y-offset", offset + "px");

        if (thread.id === activeThreadId) {
          threadEl.classList.add("active");
        } else {
          threadEl.classList.add("collapsed");
        }

        const headerEl = document.createElement("div");
        headerEl.className = "thread-header";

        const titleSpan = document.createElement("span");
        titleSpan.className = "thread-title";
        titleSpan.textContent = thread.title;

        const metaSpan = document.createElement("span");
        metaSpan.className = "thread-meta";
        metaSpan.innerHTML = `<span class="badge">${thread.id}</span>` +
          (thread.parentId ? ` ← <span class="badge">${thread.parentId}</span>` : "");

        const closeBtn = document.createElement("button");
        closeBtn.className = "thread-close-btn";
        closeBtn.textContent = "×";
        closeBtn.title = "Close this node and its branches";
        closeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          closeThread(thread.id);
        });

        headerEl.appendChild(titleSpan);
        headerEl.appendChild(metaSpan);
        headerEl.appendChild(closeBtn);

        headerEl.addEventListener("click", () => setActiveThread(thread.id));
        threadEl.appendChild(headerEl);

        const bodyEl = document.createElement("div");
        bodyEl.className = "thread-body";

        for (const msg of thread.messages) {
          const msgEl = document.createElement("div");
          msgEl.className = "msg " + msg.role;
          msgEl.dataset.messageId = msg.id;

          const metaEl = document.createElement("div");
          metaEl.className = "msg-meta";

          const roleSpan = document.createElement("span");
          roleSpan.className = "msg-role";
          roleSpan.textContent = msg.role;
          metaEl.appendChild(roleSpan);

          msgEl.appendChild(metaEl);

          const textEl = document.createElement("div");
          textEl.className = "msg-text";
          renderMessageText(msg, textEl);

          msgEl.appendChild(textEl);
          bodyEl.appendChild(msgEl);
        }

        threadEl.appendChild(bodyEl);

        const footerEl = document.createElement("div");
        footerEl.className = "thread-footer";

        const inputEl = document.createElement("input");
        inputEl.type = "text";
        inputEl.placeholder = `Type in ${thread.id}…`;

        inputEl.addEventListener("focus", () => {
          if (activeThreadId === thread.id) return;

          const prevActive = document.querySelector(".thread.active");
          if (prevActive) {
            prevActive.classList.remove("active");
            prevActive.classList.add("collapsed");
          }

          const current = inputEl.closest(".thread");
          if (current) {
            current.classList.remove("collapsed");
            current.classList.add("active");
          }

          activeThreadId = thread.id;
        });

        inputEl.onkeydown = (e) => {
          if (e.key === "Enter") {
            addUserMessage(thread.id, inputEl.value);
            inputEl.value = "";
          }
        };

        const sendBtn = document.createElement("button");
        sendBtn.textContent = "Send";
        sendBtn.onclick = () => {
          addUserMessage(thread.id, inputEl.value);
          inputEl.value = "";
        };

        footerEl.appendChild(inputEl);
        footerEl.appendChild(sendBtn);
        threadEl.appendChild(footerEl);

        col.appendChild(threadEl);
      }

      containerEl.appendChild(col);
    }

    scrollAllThreadsToBottom();

    if (pendingFocusThreadId) {
      const toFocus = pendingFocusThreadId;
      pendingFocusThreadId = null;
      setTimeout(() => {
        if (toFocus) focusInputForThread(toFocus);
      }, 0);
    }

    requestAnimationFrame(centerColumnsByTallest);
  }

  function scrollToRight() {
    containerEl.scrollLeft = containerEl.scrollWidth;
  }

  // ---------- Boot ----------
  const first = createThread({
    title: "Root 1",
    depth: 0,
    parentId: null,
    parentSnippet: null
  });
  activeThreadId = first.id;
  pendingFocusThreadId = first.id;
  render();
</script>
</body>
</html>
