<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Branching Chat – Absolute Position Engine</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 0;
      background: #050505;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 10px 16px;
      background: #080808;
      border-bottom: 1px solid #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    header h1 {
      font-size: 16px;
      margin: 0;
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    header button {
      border-radius: 999px;
      border: 1px solid #444;
      background: #151515;
      color: #eee;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    header button:hover {
      background: #222;
    }

    #thread-container {
      position: relative;
      flex: 1;
      overflow-x: auto;
      overflow-y: auto;
      padding: 80px 16px 80px 16px;
      scroll-behavior: smooth;
      background: #050505;
    }

    .thread {
      position: absolute;
      width: 340px;
      display: flex;
      flex-direction: column;
      background: #101010;
      border-radius: 10px;
      border: 1px solid #333;
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
      transition:
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        opacity 0.15s ease;
      z-index: 1;
    }

    .thread.active {
      border-color: #4ade80;
      box-shadow: 0 0 18px rgba(74, 222, 128, 0.45);
      opacity: 1;
      z-index: 2;
    }

    .thread.collapsed {
      opacity: 0.9;
    }

    .thread-header {
      padding: 6px 10px;
      border-bottom: 1px solid #222;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #151515;
      border-radius: 10px 10px 0 0;
      cursor: pointer;
      gap: 6px;
    }

    .thread-title {
      font-weight: 500;
    }

    .thread-meta {
      font-size: 10px;
      opacity: 0.7;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .thread-body {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: visible;
      flex: 0 0 auto;
    }

    .thread-footer {
      padding: 8px;
      border-top: 1px solid #222;
      display: flex;
      gap: 6px;
      background: #0b0b0b;
      border-radius: 0 0 10px 10px;
    }

    .msg {
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 13px;
      position: relative;
      white-space: pre-wrap;
    }

    .msg.user {
      align-self: flex-end;
      background: #24496e;
    }

    .msg.assistant {
      align-self: flex-start;
      background: #262626;
    }

    .msg.system {
      align-self: center;
      background: #111;
      opacity: 0.9;
      font-size: 11px;
    }

    .msg-meta {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 2px;
      display: flex;
      justify-content: space-between;
      gap: 6px;
    }

    .msg-role {
      text-transform: uppercase;
    }

    .msg-text {
      font-size: 13px;
    }

    .branch-highlight {
      background: #2a7c52;
      padding: 0 2px;
      border-radius: 2px;
    }

    input[type="text"] {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #050505;
      color: #eee;
      font-size: 13px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #555;
    }

    button {
      border: 1px solid #444;
      background: #151515;
      color: #eee;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    button:hover {
      background: #222;
    }

    .thread-close-btn {
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 11px;
      line-height: 1;
      border: 1px solid #444;
      background: #151515;
      color: #eee;
    }

    .thread-close-btn:hover {
      background: #222;
    }

    #selection-branch-btn {
      position: absolute;
      z-index: 1000;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      cursor: pointer;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }

    #connection-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
      z-index: 0;
    }

    .thread-connection {
      fill: none;
      stroke: #4ade80;
      stroke-width: 1.6;
      opacity: 0.7;
    }
  </style>
</head>
<body>
<header>
  <h1>Branching Chat (Columns by Depth)</h1>
  <div class="header-actions">
    <button id="refresh-layout-btn">↻ Refresh layout</button>
    <button id="new-root-btn">+ New root conversation</button>
  </div>
</header>

<div id="thread-container"></div>
<button id="selection-branch-btn">Branch selection →</button>

<script>
  // ---------- Data ----------
  let threadCounter = 1;
  let messageCounter = 1;
  let highlightCounter = 1;
  let activeThreadId = null;
  let pendingFocusThreadId = null;

  const threads = [];

  const COLUMN_WIDTH = 360;
  const MIN_VERTICAL_GAP = 14;
  const TOP_MARGIN = 40;

  const containerEl = document.getElementById("thread-container");
  const selectionBranchBtn = document.getElementById("selection-branch-btn");
  const newRootBtn = document.getElementById("new-root-btn");
  const refreshBtn = document.getElementById("refresh-layout-btn");

  // last branched child to anchor in its lane
  let anchoredThreadId = null;

  function setActiveThread(id) {
    activeThreadId = id;
    pendingFocusThreadId = id;
    render();
  }

  function createThread({
    title,
    depth,
    parentId = null,
    parentSnippet = null,
    visibleSnippet = null,
    branchSource = null,
    y = null
  }) {
    const id = "t" + threadCounter++;

    const messages = [];

    if (parentSnippet) {
      messages.push({
        id: "m" + messageCounter++,
        role: "system",
        content: parentSnippet,
        visibleSnippet
      });
    } else {
      messages.push({
        id: "m" + messageCounter++,
        role: "system",
        content: "You are a helpful local assistant in a root conversation node."
      });
    }

    if (y === null) {
      if (depth === 0) {
        const existingRoots = threads.filter(t => t.depth === 0).length;
        y = TOP_MARGIN + existingRoots * 260;
      } else {
        y = TOP_MARGIN;
      }
    }

    const thread = {
      id,
      depth,
      parentId,
      parentSnippet,
      title,
      messages,
      branchSource,
      seq: threadCounter,
      baseY: y,   // ideal top (content-space)
      y           // actual top (content-space)
    };

    threads.push(thread);
    if (!activeThreadId) activeThreadId = thread.id;
    return thread;
  }

  // ---------- Helpers ----------
  function keepThreadScrolledToBottom(threadId) {
    const threadEl = [...document.querySelectorAll(".thread")]
      .find(el => el.dataset.threadId === threadId);
    if (!threadEl) return;
    const bodyEl = threadEl.querySelector(".thread-body");
    if (!bodyEl) return;
    bodyEl.scrollTop = bodyEl.scrollHeight;
  }

  function focusInputForThread(threadId) {
    const inputEl = document.querySelector(
      `.thread[data-thread-id="${threadId}"] input[type="text"]`
    );
    if (!inputEl) return;

    try {
      inputEl.focus({ preventScroll: true });
    } catch {
      inputEl.focus();
    }

    const val = inputEl.value;
    inputEl.value = "";
    inputEl.value = val;
  }

  // ---------- Messaging ----------
  function addUserMessage(threadId, text) {
    const thread = threads.find(t => t.id === threadId);
    if (!thread || !text.trim()) return;

    thread.messages.push({
      id: "m" + messageCounter++,
      role: "user",
      content: text.trim()
    });

    pendingFocusThreadId = threadId;

    render();
    keepThreadScrolledToBottom(threadId);
    sendToBackend(thread);
  }

  async function sendToBackend(thread) {
    const payloadMessages = thread.messages.map(m => ({
      role: m.role,
      content: m.content
    }));

    const thinking = {
      id: "m" + messageCounter++,
      role: "assistant",
      content: "…"
    };
    thread.messages.push(thinking);

    pendingFocusThreadId = thread.id;
    render();
    keepThreadScrolledToBottom(thread.id);

    try {
      const resp = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          thread_id: thread.id,
          messages: payloadMessages
        })
      });

      const data = await resp.json();
      thinking.content = data.reply ?? "(no reply)";
      pendingFocusThreadId = thread.id;
      render();
      keepThreadScrolledToBottom(thread.id);
    } catch (err) {
      thinking.content = "Error: " + err;
      pendingFocusThreadId = thread.id;
      render();
      keepThreadScrolledToBottom(thread.id);
    }
  }

  // ---------- Selection / branching ----------
  function clearSelection() {
    const sel = window.getSelection && window.getSelection();
    if (sel && sel.removeAllRanges) sel.removeAllRanges();
  }

  function getSelectedTextInside(el) {
    const sel = window.getSelection && window.getSelection();
    if (!sel || sel.rangeCount === 0) return { raw: null, trimmed: null };

    const range = sel.getRangeAt(0);
    if (!el.contains(range.commonAncestorContainer)) {
      return { raw: null, trimmed: null };
    }

    const raw = sel.toString();
    const trimmed = raw.trim();

    if (!trimmed.length) {
      return { raw: null, trimmed: null };
    }

    return { raw, trimmed };
  }

  function computeGlobalSelectionMidIndex(parentThread, msg, rawSel, trimmedSel) {
    const selText =
      rawSel && rawSel.length
        ? rawSel
        : trimmedSel && trimmedSel.length
        ? trimmedSel
        : "";

    let totalChars = 0;
    let midGlobal = 0;

    for (const m of parentThread.messages) {
      const text = m.content || "";
      if (m === msg) {
        let idx = 0;
        if (selText) {
          const found = text.indexOf(selText);
          if (found >= 0) idx = found;
        }

        const selLen = selText ? selText.length : 1;
        const midInMsg = selLen % 2 === 1 ? (selLen - 1) / 2 : selLen / 2;

        midGlobal = totalChars + idx + midInMsg;
      }
      totalChars += text.length;
    }

    return midGlobal;
  }

  function buildContextSnippet(msg, selectedText) {
    const full = msg.content || "";
    const s = selectedText || "";

    if (!s) return full.slice(0, 1000);

    const idx = full.indexOf(s);
    if (idx === -1) return full.slice(0, 1000);

    const before = full.lastIndexOf("\n\n", idx);
    const after = full.indexOf("\n\n", idx + s.length);
    const paraStart = before === -1 ? 0 : before + 2;
    const paraEnd = after === -1 ? full.length : after;
    const paragraph = full.slice(paraStart, paraEnd).trim();

    const rest = (full.slice(0, paraStart) + "\n" + full.slice(paraEnd)).trim();
    const restTrunc = rest.slice(0, 400);

    let snippet = "";
    snippet += `Paragraph context:\n"${paragraph}"\n\n`;
    snippet += `Focused selection:\n"${s}"\n\n`;
    if (restTrunc.length) {
      snippet += `Other context from the same answer (truncated):\n"${restTrunc}"`;
    }
    return snippet;
  }

  function branchFromMessage(parentThreadId, messageId, msgElement, forcedSnippet = null) {
    const parentThread = threads.find(t => t.id === parentThreadId);
    if (!parentThread) return;

    const msg = parentThread.messages.find(m => m.id === messageId);
    if (!msg) return;

    const selInfo = getSelectedTextInside(msgElement);
    const rawSel = selInfo.raw;
    const trimmedSel = selInfo.trimmed;

    const globalMid = computeGlobalSelectionMidIndex(
      parentThread,
      msg,
      rawSel,
      trimmedSel
    );

    // Highlight center in global canvas coords
    let highlightYGlobal = parentThread.y ?? parentThread.baseY ?? TOP_MARGIN;

    const sel = window.getSelection && window.getSelection();
    if (sel && sel.rangeCount > 0) {
      const range = sel.getRangeAt(0);
      const highlightRect = range.getBoundingClientRect();
      const containerRect = containerEl.getBoundingClientRect();
      const scrollTop = containerEl.scrollTop;

      highlightYGlobal =
        highlightRect.top + highlightRect.height / 2
        - containerRect.top
        + scrollTop;
    }

    const snippet = forcedSnippet || buildContextSnippet(msg, trimmedSel);
    const newDepth = parentThread.depth + 1;
    const visibleSnippet = trimmedSel || snippet.slice(0, 120);

    const childThread = createThread({
      title: visibleSnippet || "Branch",
      depth: newDepth,
      parentId: parentThread.id,
      parentSnippet: snippet,
      visibleSnippet,
      branchSource: {
        parentThreadId: parentThread.id,
        parentMessageId: msg.id,
        position: globalMid,
        highlightY: highlightYGlobal   // store exact highlight center
      },
      y: highlightYGlobal // provisional; will be recentered by layout using card height
    });

    anchoredThreadId = childThread.id;

    if (!msg.highlights) msg.highlights = [];
    msg.highlights.push({
      id: "h" + highlightCounter++,
      text: visibleSnippet,
      targetThreadId: childThread.id
    });

    activeThreadId = childThread.id;
    pendingFocusThreadId = childThread.id;
    render();
    scrollToRight();
  }

  document.addEventListener("selectionchange", () => {
    const sel = window.getSelection && window.getSelection();
    if (!sel || sel.rangeCount === 0) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const range = sel.getRangeAt(0);
    const container = range.commonAncestorContainer;

    const msgEl = container.nodeType === 1
      ? container.closest(".msg")
      : container.parentElement && container.parentElement.closest(".msg");

    if (!msgEl) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const threadEl = msgEl.closest(".thread");
    if (!threadEl) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const selectedText = sel.toString().trim();
    if (!selectedText.length) {
      selectionBranchBtn.style.display = "none";
      return;
    }

    const rect = range.getBoundingClientRect();
    selectionBranchBtn.style.display = "block";
    selectionBranchBtn.style.left = (rect.left + rect.width / 2 - 50) + window.scrollX + "px";
    selectionBranchBtn.style.top = (rect.top - 30) + window.scrollY + "px";

    selectionBranchBtn.dataset.threadId = threadEl.dataset.threadId;
    selectionBranchBtn.dataset.messageId = msgEl.dataset.messageId;
  });

  selectionBranchBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    const threadId = selectionBranchBtn.dataset.threadId;
    const messageId = selectionBranchBtn.dataset.messageId;

    if (!threadId || !messageId) return;

    const msgEl = document.querySelector(
      `.thread[data-thread-id="${threadId}"] .msg[data-message-id="${messageId}"]`
    );
    if (!msgEl) return;

    branchFromMessage(threadId, messageId, msgEl);
    selectionBranchBtn.style.display = "none";
    clearSelection();
  });

  // ---------- Close thread ----------
  function closeThread(threadId) {
    const toDelete = new Set([threadId]);

    let changed = true;
    while (changed) {
      changed = false;
      for (const t of threads) {
        if (!toDelete.has(t.id) && t.parentId && toDelete.has(t.parentId)) {
          toDelete.add(t.id);
          changed = true;
        }
      }
    }

    threads.forEach(t => {
      t.messages.forEach(m => {
        if (m.highlights) {
          m.highlights = m.highlights.filter(
            h => !toDelete.has(h.targetThreadId)
          );
        }
      });
    });

    for (let i = threads.length - 1; i >= 0; i--) {
      if (toDelete.has(threads[i].id)) {
        threads.splice(i, 1);
      }
    }

    if (toDelete.has(activeThreadId)) {
      activeThreadId = threads.length ? threads[0].id : null;
    }

    pendingFocusThreadId = activeThreadId;
    render();
  }

  // ---------- SVG connections ----------
  const SVG_NS = "http://www.w3.org/2000/svg";

  function ensureConnectionLayer() {
    let svg = containerEl.querySelector("#connection-layer");
    if (!svg) {
      svg = document.createElementNS(SVG_NS, "svg");
      svg.id = "connection-layer";
      containerEl.prepend(svg);
    }
    svg.setAttribute("width", containerEl.scrollWidth);
    svg.setAttribute("height", containerEl.scrollHeight);
    svg.style.width = containerEl.scrollWidth + "px";
    svg.style.height = containerEl.scrollHeight + "px";
    svg.innerHTML = "";
    return { svg, containerRect: containerEl.getBoundingClientRect() };
  }

  function drawConnections() {
    if (!threads.length) return;
    const { svg, containerRect } = ensureConnectionLayer();

    const scrollLeft = containerEl.scrollLeft;
    const scrollTop = containerEl.scrollTop;

    threads.forEach(thread => {
      if (!thread.parentId) return;

      const parentEl = containerEl.querySelector(
        `.thread[data-thread-id="${thread.parentId}"]`
      );
      const childEl = containerEl.querySelector(
        `.thread[data-thread-id="${thread.id}"]`
      );
      if (!parentEl || !childEl) return;

      const anchorHighlight = parentEl.querySelector(
        `.branch-highlight[data-target-thread-id="${thread.id}"]`
      );

      let x1, y1;

      if (anchorHighlight) {
        const hr = anchorHighlight.getBoundingClientRect();
        x1 = hr.right - containerRect.left + scrollLeft;
        y1 = hr.top + hr.height / 2 - containerRect.top + scrollTop;
      } else {
        const pr = parentEl.getBoundingClientRect();
        x1 = pr.right - containerRect.left + scrollLeft;
        y1 = pr.top + pr.height / 2 - containerRect.top + scrollTop;
      }

      const headerEl = childEl.querySelector(".thread-header") || childEl;
      const cr = headerEl.getBoundingClientRect();
      const x2 = cr.left - containerRect.left + scrollLeft;
      const y2 = cr.top + cr.height / 2 - containerRect.top + scrollTop;

      const dx = (x2 - x1) * 0.5;

      const path = document.createElementNS(SVG_NS, "path");
      const d = `M ${x1} ${y1} C ${x1 + dx} ${y1} ${x2 - dx} ${y2} ${x2} ${y2}`;
      path.setAttribute("d", d);
      path.setAttribute("class", "thread-connection");

      svg.appendChild(path);
    });
  }

  function scrollToRight() {
    containerEl.scrollLeft = containerEl.scrollWidth;
  }

  // ---------- Recompute baseY from DOM for all children (refresh) ----------
  function recomputeBasePositionsFromDOM() {
    const containerRect = containerEl.getBoundingClientRect();
    const scrollTop = containerEl.scrollTop;

    // keep roots' current y as base
    threads.forEach(t => {
      if (t.depth === 0 && typeof t.y === "number") {
        t.baseY = t.y;
      }
    });

    for (const child of threads) {
      if (!child.parentId) continue;

      const parentEl = containerEl.querySelector(
        `.thread[data-thread-id="${child.parentId}"]`
      );
      if (!parentEl) continue;

      const highlightSpan = parentEl.querySelector(
        `.branch-highlight[data-target-thread-id="${child.id}"]`
      );
      if (!highlightSpan) continue;

      const hr = highlightSpan.getBoundingClientRect();
      const highlightCenterGlobal =
        hr.top + hr.height / 2 - containerRect.top + scrollTop;

      const childEl = containerEl.querySelector(
        `.thread[data-thread-id="${child.id}"]`
      );
      const h = childEl ? (childEl.offsetHeight || 200) : 200;

      child.branchSource = child.branchSource || {};
      child.branchSource.highlightY = highlightCenterGlobal;
      child.baseY = highlightCenterGlobal - h / 2;
    }
  }

  // ---------- Depth lane layout ----------
  function applyDepthLayout(centerByParents = false) {
    if (!threads.length) return;

    const depths = Array.from(new Set(threads.map(t => t.depth)));

    depths.forEach(depth => {
      const laneThreads = threads
        .filter(t => t.depth === depth)
        .sort((a, b) => (a.baseY ?? a.y) - (b.baseY ?? b.y));

      if (!laneThreads.length) return;

      const n = laneThreads.length;

      const heights = laneThreads.map(t => {
        const el = containerEl.querySelector(`.thread[data-thread-id="${t.id}"]`);
        return el ? (el.offsetHeight || 200) : 200;
      });

      const basePos = laneThreads.map(t => t.baseY ?? t.y ?? TOP_MARGIN);

      // Make anchor child’s ideal pos = highlight center - half its height
      let anchorIndex = laneThreads.findIndex(t => t.id === anchoredThreadId);

      if (centerByParents) {
        // on full refresh: use all stored highlight centers if present
        laneThreads.forEach((t, idx) => {
          if (t.branchSource && typeof t.branchSource.highlightY === "number") {
            basePos[idx] = t.branchSource.highlightY - heights[idx] / 2;
          }
        });
        anchorIndex = -1; // no special anchor
      } else if (anchorIndex !== -1) {
        const t = laneThreads[anchorIndex];
        if (t.branchSource && typeof t.branchSource.highlightY === "number") {
          basePos[anchorIndex] = t.branchSource.highlightY - heights[anchorIndex] / 2;
        }
      }

      const finalPos = new Array(n);

      if (anchorIndex === -1) {
        // simple downward collision from base
        let lastBottom = -Infinity;
        for (let i = 0; i < n; i++) {
          let top = basePos[i];
          if (top < lastBottom + MIN_VERTICAL_GAP) {
            top = lastBottom + MIN_VERTICAL_GAP;
          }
          finalPos[i] = top;
          lastBottom = top + heights[i];
        }
      } else {
        // anchor new child, move siblings around it
        finalPos[anchorIndex] = basePos[anchorIndex];

        for (let i = anchorIndex - 1; i >= 0; i--) {
          const belowTop = finalPos[i + 1] - MIN_VERTICAL_GAP - heights[i];
          const desired = basePos[i];
          finalPos[i] = Math.min(desired, belowTop);
        }

        for (let i = anchorIndex + 1; i < n; i++) {
          const aboveBottom = finalPos[i - 1] + heights[i - 1] + MIN_VERTICAL_GAP;
          const desired = basePos[i];
          finalPos[i] = Math.max(desired, aboveBottom);
        }
      }

      // (simple version) no parent-cluster centering yet; that will be the next evolution for your point (3)

      laneThreads.forEach((thread, idx) => {
        const top = finalPos[idx];
        thread.y = top;
        const el = containerEl.querySelector(`.thread[data-thread-id="${thread.id}"]`);
        if (el) el.style.top = top + "px";
      });
    });

    anchoredThreadId = null;

    // global re-base so highest card is at TOP_MARGIN
    let minY = Infinity;
    threads.forEach(t => {
      if (typeof t.y === "number" && t.y < minY) minY = t.y;
    });

    if (minY === Infinity) return;

    const shiftDown = TOP_MARGIN - minY;
    if (shiftDown > 0) {
      threads.forEach(t => {
        t.y += shiftDown;
        if (typeof t.baseY === "number") t.baseY += shiftDown;
        const el = containerEl.querySelector(`.thread[data-thread-id="${t.id}"]`);
        if (el) el.style.top = t.y + "px";
      });
    }
  }

  // ---------- Rendering ----------
  newRootBtn.onclick = () => {
    const t = createThread({
      title: "Root " + threadCounter,
      depth: 0,
      parentId: null,
      parentSnippet: null
    });
    anchoredThreadId = null;
    activeThreadId = t.id;
    pendingFocusThreadId = t.id;
    render();
    scrollToRight();
  };

  refreshBtn.onclick = () => {
    requestAnimationFrame(() => {
      recomputeBasePositionsFromDOM();
      anchoredThreadId = null;
      applyDepthLayout(true);   // use highlight centers for all children
      drawConnections();
    });
  };

  function renderMessageText(msg, container) {
    const baseText = msg.visibleSnippet
      ? `Branch context: "${msg.visibleSnippet}"`
      : msg.content;

    if (!msg.highlights || msg.highlights.length === 0) {
      container.textContent = baseText;
      return;
    }

    const text = baseText;
    const highlights = msg.highlights.slice();

    highlights.sort((a, b) => {
      const ia = text.indexOf(a.text);
      const ib = text.indexOf(b.text);
      return ia - ib;
    });

    let cursor = 0;

    for (const h of highlights) {
      const idx = text.indexOf(h.text, cursor);
      if (idx === -1) continue;

      if (idx > cursor) {
        container.appendChild(
          document.createTextNode(text.slice(cursor, idx))
        );
      }

      const span = document.createElement("span");
      span.className = "branch-highlight";
      span.dataset.highlightId = h.id;
      span.dataset.targetThreadId = h.targetThreadId;
      span.textContent = h.text;
      container.appendChild(span);

      cursor = idx + h.text.length;
    }

    if (cursor < text.length) {
      container.appendChild(document.createTextNode(text.slice(cursor)));
    }
  }

  function render() {
    const prevScrollTop = containerEl.scrollTop;
    const prevScrollLeft = containerEl.scrollLeft;

    containerEl.innerHTML = "";

    if (!threads.length) return;
    if (!activeThreadId && threads.length > 0) {
      activeThreadId = threads[0].id;
    }

    for (const thread of threads) {
      const threadEl = document.createElement("div");
      threadEl.className = "thread";
      threadEl.dataset.threadId = thread.id;

      const left = thread.depth * COLUMN_WIDTH;
      const top = thread.y ?? thread.baseY ?? TOP_MARGIN;
      threadEl.style.left = left + "px";
      threadEl.style.top = top + "px";

      if (thread.id === activeThreadId) {
        threadEl.classList.add("active");
      } else {
        threadEl.classList.add("collapsed");
      }

      threadEl.addEventListener("click", (e) => {
        const sel = window.getSelection && window.getSelection();
        if (sel && sel.toString().trim()) return;
        if (e.target.closest("input") || e.target.closest("button")) return;
        setActiveThread(thread.id);
      });

      const headerEl = document.createElement("div");
      headerEl.className = "thread-header";

      const titleSpan = document.createElement("span");
      titleSpan.className = "thread-title";
      titleSpan.textContent = thread.title;

      const metaSpan = document.createElement("span");
      metaSpan.className = "thread-meta";
      metaSpan.textContent = thread.depth === 0 ? "Root" : `Depth ${thread.depth}`;

      const closeBtn = document.createElement("button");
      closeBtn.className = "thread-close-btn";
      closeBtn.textContent = "×";
      closeBtn.title = "Close this node and its branches";
      closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        closeThread(thread.id);
      });

      headerEl.appendChild(titleSpan);
      headerEl.appendChild(metaSpan);
      headerEl.appendChild(closeBtn);
      headerEl.addEventListener("click", () => setActiveThread(thread.id));
      threadEl.appendChild(headerEl);

      const bodyEl = document.createElement("div");
      bodyEl.className = "thread-body";

      for (const msg of thread.messages) {
        const msgEl = document.createElement("div");
        msgEl.className = "msg " + msg.role;
        msgEl.dataset.messageId = msg.id;

        const metaEl = document.createElement("div");
        metaEl.className = "msg-meta";

        const roleSpan = document.createElement("span");
        roleSpan.className = "msg-role";
        roleSpan.textContent = msg.role;
        metaEl.appendChild(roleSpan);

        msgEl.appendChild(metaEl);

        const textEl = document.createElement("div");
        textEl.className = "msg-text";
        renderMessageText(msg, textEl);

        msgEl.appendChild(textEl);
        bodyEl.appendChild(msgEl);
      }

      threadEl.appendChild(bodyEl);

      const footerEl = document.createElement("div");
      footerEl.className = "thread-footer";

      const inputEl = document.createElement("input");
      inputEl.type = "text";
      inputEl.placeholder = `Type in ${thread.id}…`;

      inputEl.addEventListener("focus", () => {
        if (activeThreadId === thread.id) return;

        const prevActive = document.querySelector(".thread.active");
        if (prevActive) {
          prevActive.classList.remove("active");
          prevActive.classList.add("collapsed");
        }

        const current = inputEl.closest(".thread");
        if (current) {
          current.classList.remove("collapsed");
          current.classList.add("active");
        }

        activeThreadId = thread.id;
      });

      inputEl.onkeydown = (e) => {
        if (e.key === "Enter") {
          addUserMessage(thread.id, inputEl.value);
          inputEl.value = "";
        }
      };

      const sendBtn = document.createElement("button");
      sendBtn.textContent = "Send";
      sendBtn.onclick = () => {
        addUserMessage(thread.id, inputEl.value);
        inputEl.value = "";
      };

      footerEl.appendChild(inputEl);
      footerEl.appendChild(sendBtn);
      threadEl.appendChild(footerEl);

      containerEl.appendChild(threadEl);
    }

    requestAnimationFrame(() => {
      containerEl.scrollTop = prevScrollTop;
      containerEl.scrollLeft = prevScrollLeft;

      if (pendingFocusThreadId) {
        const toFocus = pendingFocusThreadId;
        pendingFocusThreadId = null;
        focusInputForThread(toFocus);
      }

      applyDepthLayout(false);  // incremental layout
      drawConnections();
    });
  }

  // ---------- Boot ----------
  const first = createThread({
    title: "Root 1",
    depth: 0,
    parentId: null,
    parentSnippet: null
  });
  activeThreadId = first.id;
  pendingFocusThreadId = first.id;
  render();
</script>
</body>
</html>
